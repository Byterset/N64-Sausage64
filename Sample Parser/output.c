/***************************************************************
                           texture.c
                             
Outputs the parsed data to a file
***************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>
#include "main.h"
#include "texture.h"
#include "mesh.h"
#include "animation.h"
#include "dlist.h"
#include "opengl.h"

#define BINARY_VERSION 0
#define STRBUF_SIZE 512

#define member_size(type, member) (sizeof( ((type *)0)->member ))

typedef struct {
    uint32_t header;
    uint16_t count_meshes;
    uint16_t count_anims;
    uint32_t offset_meshes;
    uint32_t offset_anims;
} BinFile;

typedef struct {
    uint32_t meshdata_offset;
    uint32_t meshdata_size;
    uint32_t vertdata_offset;
    uint32_t vertdata_size;
    uint32_t dldata_offset;
    uint32_t dldata_size;
    uint32_t dldata_slotcount;
} BinFile_TOC_Meshes;

typedef struct {
    uint8_t is_billboard;
    int16_t parent;
    char*   name;
} BinFile_MeshData;

typedef struct {
    int16_t  pos[3];
    uint16_t pad;
    int16_t  tex[2];
    uint8_t  colornormal[4];
} BinFile_UltraVert;

typedef struct {
    float pos[3];
    float tex[2];
    float normal[3];
    float color[3];
} BinFile_DragonVert;

typedef struct {
    uint32_t animdata_offset;
    uint32_t animdata_size;
    uint32_t kfdata_offset;
    uint32_t kfdata_size;
} BinFile_TOC_Anims;

typedef struct {
    uint16_t kfcount;
    uint16_t* kfindices;
    char* name;
} BinFile_AnimData;

typedef struct {
    float pos[3];
    float rot[4];
    float scale[3];
} BinFile_KeyFrame;


/*==============================
    write_header
    Writes the header data to a text file.
    @param The file pointer
    @param Whether to generate helper macros
==============================*/

static void write_header(FILE* fp, bool makemacros)
{
    int i;
    int count;
    listNode* curnode;
    int longestmeshname = 0, longestanimname = 0;
        
    // Find the mesh and animation with the longest name
    for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
    {
        s64Mesh* mesh = (s64Mesh*)curnode->data;
        int len = strlen(mesh->name);
        if (len > longestmeshname)
            longestmeshname = len;
    }
    for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
    {
        s64Anim* anim = (s64Anim*)curnode->data;
        int len = strlen(anim->name);
        if (len > longestanimname)
            longestanimname = len;
    }

    // Print the header
    fprintf(fp, "// Generated by "PROGRAM_NAME" V"PROGRAM_VERSION"\n");
    fprintf(fp, "// By Buu342\n\n");
    
    // Create some helper macros
    if (makemacros)
    {
        // Iterate through all the meshes and print their names
        count = 0;
        fprintf(fp, "// Mesh data\n#define MESHCOUNT_%s %d\n\n", global_modelname, list_meshes.size);
        for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
        {
            s64Mesh* mesh = (s64Mesh*)curnode->data;
            int nspaces = strlen(mesh->name);
            fprintf(fp, "#define MESH_%s_%s ", global_modelname, mesh->name);
            for (i=nspaces; i<longestmeshname; i++) fputc(' ', fp);
            fprintf(fp, "%d\n", count++);
        }
        fputs("\n", fp);
        
        // Iterate through all the animations and print their names
        count = 0;
        fprintf(fp, "// Animation data\n#define ANIMATIONCOUNT_%s %d\n\n", global_modelname, list_animations.size);
        for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
        {
            s64Anim* anim = (s64Anim*)curnode->data;
            int nspaces = strlen(anim->name);
            fprintf(fp, "#define ANIMATION_%s_%s ", global_modelname, anim->name);
            for (i=nspaces; i<longestanimname; i++) fputc(' ', fp);
            fprintf(fp, "%d\n", count++);
        }
        fputs("\n", fp);
    }
}


/*==============================
    write_output_text
    Writes the output to a text file
==============================*/

void write_output_text()
{
    int i;
    FILE* fp;
    FILE* fp_temp;
    listNode* curnode;
    int tempc;
    char strbuff[STRBUF_SIZE];
    bool makestructs = (list_animations.size > 0 || list_meshes.size > 1);

    // Open the file
    sprintf(strbuff, "%s.h", global_outputname);
    fp = fopen(strbuff, "w+");
    if (fp == NULL)
        terminate("Error: Unable to open file for writing\n");
        
    // Print the header
    write_header(fp, makestructs);

    // Construct a text display list
    if (!global_opengl)
        construct_dltext();
    else
        construct_opengl();
    
    // Dump our temporary file into our final file, and then remove it after we're done
    sprintf(strbuff, "temp_%s", global_outputname);
    fp_temp = fopen(strbuff, "r+");
    if (fp_temp == NULL)
        terminate("Error: Unable to open temporary file for reading\n");
    while ((tempc = fgetc(fp_temp)) != EOF)
       fputc(tempc, fp);
    fclose(fp_temp);
    remove(strbuff);
    
    // Write the animation data
    if (list_animations.size > 0)
    {
        fputs("\n", fp);
        fputs("/*********************************\n"
              "          Animation Data\n"
              "*********************************/", fp);
        for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
        {
            listNode* keyfnode;
            s64Anim* anim = (s64Anim*)curnode->data;
            fputs("\n\n", fp);
            
            // Print an array of framedata
            for (keyfnode = anim->keyframes.head; keyfnode != NULL; keyfnode = keyfnode->next)
            {
                listNode* meshnode;
                s64Keyframe* keyf = (s64Keyframe*)keyfnode->data;
                fprintf(fp, "static s64Transform anim_%s_%s_framedata%d[] = {\n", global_modelname, anim->name, keyf->keyframe);
                for (meshnode = list_meshes.head; meshnode != NULL; meshnode = meshnode->next) // Iterating meshes because they can be out of order to the frame data, due to texture sorting optimization
                {
                    listNode* fdatanode;
                    for (fdatanode = keyf->framedata.head; fdatanode != NULL; fdatanode = fdatanode->next)
                    {
                        s64Transform* fdata = (s64Transform*)fdatanode->data;
                        if (meshnode->data == fdata->mesh)
                        {
                            fprintf(fp, "    {{%.4ff, %.4ff, %.4ff}, {%.4ff, %.4ff, %.4ff, %.4ff}, {%.4ff, %.4ff, %.4ff}},\n", 
                                fdata->translation.x, fdata->translation.y, fdata->translation.z,
                                fdata->rotation.w, fdata->rotation.x, fdata->rotation.y, fdata->rotation.z,
                                fdata->scale.x, fdata->scale.y, fdata->scale.z
                            );
                            break;
                        }
                    }
                }
                fprintf(fp, "};\n");
            }
            
            // Then print an array of keyframes
            fprintf(fp, "static s64KeyFrame anim_%s_%s_keyframes[] = {\n", global_modelname, anim->name);
            for (keyfnode = anim->keyframes.head; keyfnode != NULL; keyfnode = keyfnode->next)
            {
                s64Keyframe* keyf = (s64Keyframe*)keyfnode->data;
                fprintf(fp, "    {%d, anim_%s_%s_framedata%d},\n", keyf->keyframe, global_modelname, anim->name, keyf->keyframe);
            }
            fprintf(fp, "};");
        }
    }
    
    // Finally, print the Sausage64 structs
    if (makestructs)
    {
        bool ismultimesh = (list_meshes.size > 1);
        
        // Struct comment header
        fputs("\n\n\n", fp);
        fputs("/*********************************\n"
              "        Sausage64 Structs\n"
              "*********************************/\n", fp);
        fputs("\n", fp);
        
        // Mesh list
        fprintf(fp, "static s64Mesh meshes_%s[] = {\n", global_modelname);
        for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
        {
            bool billboard = FALSE;
            s64Mesh* mesh = (s64Mesh*)curnode->data;
            
            // Write the model data line
            fprintf(fp, "    {\"%s\", %d, ", mesh->name, has_property(mesh, "Billboard"));
            if (global_opengl)
                fputs("&", fp);
            if (ismultimesh)
                fprintf(fp, "gfx_%s_%s, ", global_modelname, mesh->name);
            else
                fprintf(fp, "gfx_%s, ", global_modelname);
            if (mesh->parent != NULL)
            {
                int index = 0;
                listNode* pnode;

                for (pnode = list_meshes.head; pnode != NULL; pnode = pnode->next)
                {
                    s64Mesh* parent = (s64Mesh*)pnode->data;
                    if (!strcmp(parent->name, mesh->parent))
                    {
                        fprintf(fp, "%d", index);
                        break;
                    }
                    index++;
                }
            }
            else
                fprintf(fp, "-1");

            fprintf(fp, "},\n");
        }
        fputs("};\n\n", fp);
        
        // Animation list
        fprintf(fp, "static s64Animation anims_%s[] = {\n", global_modelname);
        for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
        {
            s64Anim* anim = (s64Anim*)curnode->data;
            fprintf(fp, "    {\"%s\", %d, anim_%s_%s_keyframes},\n", anim->name, anim->keyframes.size, global_modelname, anim->name);
        }
        fputs("};\n\n", fp);

        // Final model data
        fprintf(fp, "static s64ModelData mdl_%s = {%d, %d, meshes_%s, anims_%s};", global_modelname, list_meshes.size, list_animations.size, global_modelname, global_modelname);
    }
    
    // Finish
    if (!global_quiet) printf("Wrote output to '%s.h'\n", global_outputname);
    fclose(fp);
}


/*==============================
    write_output_binary
    Writes the output to a binary file.
==============================*/

void write_output_binary()
{
    int i;
    FILE* fp;
    listNode* curnode;
    char strbuff[STRBUF_SIZE];
    BinFile bin;
    BinFile_TOC_Meshes* toc_meshes;
    BinFile_MeshData* meshdatas;
    uint32_t** dldatas;
    void* vertdatas;
    int* vtotal;
    BinFile_TOC_Anims* toc_anims;
    BinFile_AnimData* animdatas;
    BinFile_KeyFrame** kfdatas;
    int* kftotal;
    bool makestructs = (list_animations.size > 0 || list_meshes.size > 1);
    
    // Open the file
    sprintf(strbuff, "%s.bin", global_outputname);
    fp = fopen(strbuff, "wb+");
    if (fp == NULL)
        terminate("Error: Unable to open file for writing\n");
    
    // Generate the file header
    bin.header        = (('S' << 24) | ('6' << 16) | ('4' << 8) | BINARY_VERSION);
    bin.count_meshes  = list_meshes.size;
    bin.count_anims   = list_animations.size;

    // Malloc stuff
    toc_meshes = (BinFile_TOC_Meshes*)malloc(sizeof(BinFile_TOC_Meshes)*list_meshes.size);
    if (toc_meshes == NULL)
        terminate("Error: Unable to malloc for TOC_Meshes\n");
    meshdatas = (BinFile_MeshData*)malloc(sizeof(BinFile_MeshData)*list_meshes.size);
    if (meshdatas == NULL)
        terminate("Error: Unable to malloc for MeshData\n");
    if (!global_opengl)
        vertdatas = (BinFile_UltraVert**)malloc(sizeof(BinFile_UltraVert*)*list_meshes.size);
    else
        vertdatas = (BinFile_DragonVert**)malloc(sizeof(BinFile_DragonVert*)*list_meshes.size);
    if (vertdatas == NULL)
        terminate("Error: Unable to malloc for Verts\n");
    dldatas = (uint32_t**)malloc(sizeof(uint32_t*)*list_meshes.size);
    if (dldatas == NULL)
        terminate("Error: Unable to malloc for DLData\n");
    vtotal = (int*)malloc(sizeof(int)*list_meshes.size);
    if (vtotal == NULL)
        terminate("Error: Unable to malloc for vtotal\n");
    kftotal = (int*)malloc(sizeof(int)*list_animations.size);
    if (kftotal == NULL)
        terminate("Error: Unable to malloc for kftotal\n");
    kfdatas = (BinFile_KeyFrame**)malloc(sizeof(BinFile_KeyFrame*)*list_animations.size);
    if (kfdatas == NULL)
        terminate("Error: Unable to malloc for KFDatas\n");

    // Generate the mesh data
    i = 0;
    for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
    {
        int parent = 0;
        s64Mesh* mesh = (s64Mesh*)curnode->data;

        // Find the parent mesh
        if (mesh->parent != NULL)
        {
            listNode* pnode;
            for (pnode = list_meshes.head; pnode != NULL; pnode = pnode->next)
            {
                s64Mesh* p = (s64Mesh*)pnode->data;
                if (!strcmp(p->name, mesh->parent))
                    break;
                parent++;
            }
        }
        else
            parent = -1;

        // Assign the meshdata
        meshdatas[i].parent = parent;
        meshdatas[i].is_billboard = has_property(mesh, "Billboard");
        meshdatas[i].name = mesh->name;

        // Update the mesh data size and offset
        toc_meshes[i].meshdata_size = member_size(BinFile_MeshData, parent) 
                                    + member_size(BinFile_MeshData, is_billboard)
                                    + strlen(meshdatas[i].name)+1;
        if (i == 0)
            toc_meshes[i].meshdata_offset = (member_size(BinFile, header) 
                                        + member_size(BinFile, count_meshes)
                                        + member_size(BinFile, count_anims)
                                        + member_size(BinFile, offset_meshes)
                                        + member_size(BinFile, offset_anims))
                                        +(member_size(BinFile_TOC_Meshes, meshdata_offset)
                                        + member_size(BinFile_TOC_Meshes, meshdata_size)
                                        + member_size(BinFile_TOC_Meshes, vertdata_offset)
                                        + member_size(BinFile_TOC_Meshes, vertdata_size)
                                        + member_size(BinFile_TOC_Meshes, dldata_offset)
                                        + member_size(BinFile_TOC_Meshes, dldata_size)
                                        + member_size(BinFile_TOC_Meshes, dldata_slotcount))
                                        *list_meshes.size;
        else
            toc_meshes[i].meshdata_offset = toc_meshes[i-1].dldata_offset + toc_meshes[i-1].dldata_size;

        // Create the vert data
        if (!global_opengl)
        {
            int j = 0;
            listNode* vcachenode;

            // Get the total vert count
            vtotal[i] = 0;
            for (vcachenode = mesh->vertcache.head; vcachenode != NULL; vcachenode = vcachenode->next)
            {
                vertCache* vcache = (vertCache*)vcachenode->data;
                listNode* vertnode;
                
                // Cycle through all the verts
                for (vertnode = vcache->verts.head; vertnode != NULL; vertnode = vertnode->next)
                    vtotal[i]++;
            }

            ((BinFile_UltraVert**)vertdatas)[i] = (BinFile_UltraVert*)malloc(sizeof(BinFile_UltraVert)*vtotal[i]);
            if (((BinFile_UltraVert**)vertdatas)[i] == NULL)
                terminate("Error: Unable to malloc for vert data\n");

            // Copy the vert data by cycling through the vcache blocks
            for (vcachenode = mesh->vertcache.head; vcachenode != NULL; vcachenode = vcachenode->next)
            {
                vertCache* vcache = (vertCache*)vcachenode->data;
                listNode* vertnode;
                
                // Cycle through all the verts
                for (vertnode = vcache->verts.head; vertnode != NULL; vertnode = vertnode->next)
                {
                    int texturew = 0, textureh = 0;
                    s64Vert* vert = (s64Vert*)vertnode->data;
                    n64Texture* tex = find_texture_fromvert(&vcache->faces, vert);
                    Vector3D normorcol = {0, 0, 0};
                    
                    // Ensure the texture is valid
                    if (tex == NULL)
                        terminate("Error: Inconsistent face/vertex texture information\n");
                    
                    // Retrieve texture/normal/color data for this vertex
                    switch (tex->type)
                    {
                        case TYPE_TEXTURE:
                            // Get the texture size
                            texturew = (tex->data).image.w;
                            textureh = (tex->data).image.h;
                            
                            // Intentional fallthrough
                        case TYPE_PRIMCOL:
                            // Pick vertex normals or vertex colors, depending on the texture flag
                            if (tex_hasgeoflag(tex, "G_LIGHTING"))
                                normorcol = vector_scale(vert->normal, 127);
                            else
                                normorcol = vector_scale(vert->color, 255);
                            break;
                        case TYPE_OMIT:
                            break;
                    }

                    // Dump the vert data
                    ((BinFile_UltraVert**)vertdatas)[i][j].pos[0] = round(vert->pos.x);
                    ((BinFile_UltraVert**)vertdatas)[i][j].pos[1] = round(vert->pos.y);
                    ((BinFile_UltraVert**)vertdatas)[i][j].pos[2] = round(vert->pos.z);
                    ((BinFile_UltraVert**)vertdatas)[i][j].pad = 0;
                    ((BinFile_UltraVert**)vertdatas)[i][j].tex[0] = float_to_s10p5(vert->UV.x*texturew);
                    ((BinFile_UltraVert**)vertdatas)[i][j].tex[1] = float_to_s10p5(vert->UV.y*textureh);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[0] = round(normorcol.x);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[1] = round(normorcol.y);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[2] = round(normorcol.z);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[3] = 255;
                    j++;
                }
            }

            // Update the vert data size and offset in the TOC
            toc_meshes[i].vertdata_size = (member_size(BinFile_UltraVert, pos)
                                        + member_size(BinFile_UltraVert, pad) 
                                        + member_size(BinFile_UltraVert, tex)
                                        + member_size(BinFile_UltraVert, colornormal)
                                        )*vtotal[i];
        }
        else
        {
            /*int j = 0;
            listNode* vertnode;
            ((BinFile_DragonVert**)vertdatas)[i] = (BinFile_DragonVert*)malloc(sizeof(BinFile_DragonVert)*vtotal);
            if (((BinFile_DragonVert**)vertdatas)[i] == NULL)
                terminate("Error: Unable to malloc for vert data\n");

            // Copy the vert data
            for (vertnode = mesh->verts.head; vertnode != NULL; vertnode = vertnode->next)
            {
                s64Vert* vert = (s64Vert*)vertnode->data;
                ((BinFile_DragonVert**)vertdatas)[i][j].pos[0] = vert->pos.x;
                ((BinFile_DragonVert**)vertdatas)[i][j].pos[1] = vert->pos.y;
                ((BinFile_DragonVert**)vertdatas)[i][j].pos[2] = vert->pos.z;
                ((BinFile_DragonVert**)vertdatas)[i][j].tex[0] = vert->UV.x;
                ((BinFile_DragonVert**)vertdatas)[i][j].tex[1] = vert->UV.y;
                ((BinFile_DragonVert**)vertdatas)[i][j].normal[0] = vert->normal.x;
                ((BinFile_DragonVert**)vertdatas)[i][j].normal[1] = vert->normal.y;
                ((BinFile_DragonVert**)vertdatas)[i][j].normal[2] = vert->normal.z;
                ((BinFile_DragonVert**)vertdatas)[i][j].color[0] = vert->color.x;
                ((BinFile_DragonVert**)vertdatas)[i][j].color[1] = vert->color.y;
                ((BinFile_DragonVert**)vertdatas)[i][j].color[2] = vert->color.z;
                j++;
            }

            // Update the vert data size in the TOC
            //toc_meshes[i].vertdata_size = sizeof(BinFile_DragonVert)*vtotal;
            */
        }
        toc_meshes[i].vertdata_offset = toc_meshes[i].meshdata_offset + toc_meshes[i].meshdata_size;

        // Create the display list
        if (!global_opengl)
        {
            int offset = 0;
            int finalsize = 0;
            int slotcount = 0;
            listNode* dllnode;
            linkedList* dllist = dlist_frommesh(mesh, TRUE);

            // Count the finalsize and slotcount
            for (dllnode = dllist->head; dllnode != NULL; dllnode = dllnode->next)
            {
                DLCBinary* bindl = (DLCBinary*)dllnode->data;
                finalsize += (1 + bindl->size)*sizeof(uint32_t);
                slotcount += commands_f3dex2[bindl->cmd].size;
            }

            // Update the TOC
            toc_meshes[i].dldata_size = finalsize;
            toc_meshes[i].dldata_slotcount = slotcount;
            toc_meshes[i].dldata_offset = toc_meshes[i].vertdata_offset + toc_meshes[i].vertdata_size;

            // Malloc the final data buffer
            dldatas[i] = (uint32_t*)calloc(finalsize, 1);
            if (dldatas[i] == NULL)
                terminate("Error: Unable to malloc for DLData\n");

            // Copy the binary list to the final data buffer
            for (dllnode = dllist->head; dllnode != NULL; dllnode = dllnode->next)
            {
                DLCBinary* bindl = (DLCBinary*)dllnode->data;
                dldatas[i][offset] = swap_endian32(bindl->cmd);
                offset++;
                memcpy(&dldatas[i][offset], bindl->data, sizeof(uint32_t)*bindl->size);
                offset += bindl->size;
            }

            // Cleanup memory
            for (dllnode = dllist->head; dllnode != NULL; dllnode = dllnode->next)
                free(((DLCBinary*)dllnode->data)->data);
            list_destroy_deep(dllist);
        }
        else
        {

        }

        // Done
        i++;
    }

    // -------------- Animation Data --------------

    // Update the header's animation offset
    bin.offset_anims = toc_meshes[list_meshes.size-1].dldata_offset + toc_meshes[list_meshes.size-1].dldata_size;

    // Create the animation TOC
    toc_anims = (BinFile_TOC_Anims*)malloc(sizeof(BinFile_TOC_Anims)*list_animations.size);
    if (toc_anims == NULL)
        terminate("Error: Unable to malloc for TOC_Anims\n");
    animdatas = (BinFile_AnimData*)malloc(sizeof(BinFile_AnimData)*list_animations.size);
    if (animdatas == NULL)
        terminate("Error: Unable to malloc for AnimData\n");
    i = 0;
    for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
    {
        int j=0;
        listNode* kfnode;
        listNode* meshnode;
        s64Anim* anim = (s64Anim*)curnode->data;

        // Assign the animdatas
        animdatas[i].kfcount = anim->keyframes.size;
        animdatas[i].kfindices = (uint16_t*)malloc(sizeof(uint16_t)*anim->keyframes.size);
        if (animdatas[i].kfindices == NULL)
            terminate("Error: Unable to malloc for AnimData kfindices\n");
        for (kfnode = anim->keyframes.head; kfnode != NULL; kfnode = kfnode->next)
            animdatas[i].kfindices[j++] = ((s64Keyframe*)kfnode->data)->keyframe;
        animdatas[i].name = anim->name;

        // Assign some keyframe data
        kftotal[i] = animdatas[i].kfcount*list_meshes.size;
        for (kfnode = anim->keyframes.head; kfnode != NULL; kfnode = kfnode->next)
        {
            kfdatas[i] = (BinFile_KeyFrame*)malloc(sizeof(BinFile_KeyFrame)*kftotal[i]);
            if (kfdatas[i] == NULL)
                terminate("Error: Unable to malloc for AnimData kfdatas\n");
        }

        // Update the anim data size and offset
        toc_anims[i].animdata_size = member_size(BinFile_AnimData, kfcount) 
                                    + (sizeof(uint16_t)*animdatas[i].kfcount)
                                    + strlen(animdatas[i].name)+1;
        if (i == 0)
            toc_anims[i].animdata_offset = bin.offset_anims +
                                            (member_size(BinFile_TOC_Anims, animdata_offset) +
                                            member_size(BinFile_TOC_Anims, animdata_size) +
                                            member_size(BinFile_TOC_Anims, kfdata_offset) +
                                            member_size(BinFile_TOC_Anims, kfdata_size))
                                            *list_animations.size;
        else
            toc_anims[i].animdata_offset = toc_anims[i-1].kfdata_offset + toc_anims[i-1].kfdata_size;
        toc_anims[i].kfdata_size = (member_size(BinFile_KeyFrame, pos) + member_size(BinFile_KeyFrame, rot) + member_size(BinFile_KeyFrame, scale))*animdatas[i].kfcount*list_meshes.size;
        toc_anims[i].kfdata_offset = toc_anims[i].animdata_offset + toc_anims[i].animdata_size;
        j=0;
        for (kfnode = anim->keyframes.head; kfnode != NULL; kfnode = kfnode->next)
        {
            s64Keyframe* keyf = (s64Keyframe*)kfnode->data;
            for (meshnode = list_meshes.head; meshnode != NULL; meshnode = meshnode->next) // Iterating meshes because they can be out of order to the frame data, due to texture sorting optimization
            {
                listNode* fdatanode;
                for (fdatanode = keyf->framedata.head; fdatanode != NULL; fdatanode = fdatanode->next)
                {
                    s64Transform* fdata = (s64Transform*)fdatanode->data;
                    if (meshnode->data == fdata->mesh)
                    {
                        kfdatas[i][j].pos[0] = fdata->translation.x;
                        kfdatas[i][j].pos[1] = fdata->translation.y;
                        kfdatas[i][j].pos[2] = fdata->translation.z;
                        kfdatas[i][j].rot[0] = fdata->rotation.w;
                        kfdatas[i][j].rot[1] = fdata->rotation.x;
                        kfdatas[i][j].rot[2] = fdata->rotation.y;
                        kfdatas[i][j].rot[3] = fdata->rotation.z;
                        kfdatas[i][j].scale[0] = fdata->scale.x;
                        kfdatas[i][j].scale[1] = fdata->scale.y;
                        kfdatas[i][j].scale[2] = fdata->scale.z;
                        j++;
                        break;
                    }
                }
            }
        }

        // Done
        i++;
    }


    // -------------- Actually start writing the binary file now --------------

    // Write the file header
    bin.header        = swap_endian32(bin.header);
    bin.count_meshes  = swap_endian16(bin.count_meshes);
    bin.count_anims   = swap_endian16(bin.count_anims);
    bin.offset_meshes = swap_endian32(16);
    bin.offset_anims  = swap_endian32(bin.offset_anims);
    fwrite(&bin.header, member_size(BinFile, header), 1, fp);
    fwrite(&bin.count_meshes, member_size(BinFile, count_meshes), 1, fp);
    fwrite(&bin.count_anims, member_size(BinFile, count_anims), 1, fp);
    fwrite(&bin.offset_meshes, member_size(BinFile, offset_meshes), 1, fp);
    fwrite(&bin.offset_anims, member_size(BinFile, offset_anims), 1, fp);

    // Write the mesh TOCs
    for (i=0; i<list_meshes.size; i++)
    {
        toc_meshes[i].meshdata_offset = swap_endian32(toc_meshes[i].meshdata_offset);
        toc_meshes[i].meshdata_size = swap_endian32(toc_meshes[i].meshdata_size);
        toc_meshes[i].vertdata_offset = swap_endian32(toc_meshes[i].vertdata_offset);
        toc_meshes[i].vertdata_size = swap_endian32(toc_meshes[i].vertdata_size);
        toc_meshes[i].dldata_offset = swap_endian32(toc_meshes[i].dldata_offset);
        toc_meshes[i].dldata_size = swap_endian32(toc_meshes[i].dldata_size);
        toc_meshes[i].dldata_slotcount = swap_endian32(toc_meshes[i].dldata_slotcount);
        fwrite(&toc_meshes[i].meshdata_offset, member_size(BinFile_TOC_Meshes, meshdata_offset), 1, fp);
        fwrite(&toc_meshes[i].meshdata_size, member_size(BinFile_TOC_Meshes, meshdata_size), 1, fp);
        fwrite(&toc_meshes[i].vertdata_offset, member_size(BinFile_TOC_Meshes, vertdata_offset), 1, fp);
        fwrite(&toc_meshes[i].vertdata_size, member_size(BinFile_TOC_Meshes, vertdata_size), 1, fp);
        fwrite(&toc_meshes[i].dldata_offset, member_size(BinFile_TOC_Meshes, dldata_offset), 1, fp);
        fwrite(&toc_meshes[i].dldata_size, member_size(BinFile_TOC_Meshes, dldata_size), 1, fp);
        fwrite(&toc_meshes[i].dldata_slotcount, member_size(BinFile_TOC_Meshes, dldata_slotcount), 1, fp);
    }

    // Write the mesh data + verts + dl
    for (i=0; i<list_meshes.size; i++)
    {
        int j;
        meshdatas[i].parent = swap_endian16(meshdatas[i].parent);
        fwrite(&meshdatas[i].parent, member_size(BinFile_MeshData, parent), 1, fp);
        fwrite(&meshdatas[i].is_billboard, member_size(BinFile_MeshData, is_billboard), 1, fp);
        fwrite(meshdatas[i].name, strlen(meshdatas[i].name)+1, 1, fp);
        if (!global_opengl)
        {
            for (j=0; j<vtotal[i]; j++)
            {
                ((BinFile_UltraVert**)vertdatas)[i][j].pos[0] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pos[0]);
                ((BinFile_UltraVert**)vertdatas)[i][j].pos[1] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pos[1]);
                ((BinFile_UltraVert**)vertdatas)[i][j].pos[2] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pos[2]);
                ((BinFile_UltraVert**)vertdatas)[i][j].pad = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pad);
                ((BinFile_UltraVert**)vertdatas)[i][j].tex[0] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].tex[0]);
                ((BinFile_UltraVert**)vertdatas)[i][j].tex[1] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].tex[1]);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].pos[0], member_size(BinFile_UltraVert, pos), 1, fp);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].pad, member_size(BinFile_UltraVert, pad), 1, fp);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].tex[0], member_size(BinFile_UltraVert, tex), 1, fp);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].colornormal[0], member_size(BinFile_UltraVert, colornormal), 1, fp);
            }
            fwrite(dldatas[i], swap_endian32(toc_meshes[i].dldata_size), 1, fp);
        }
        else
            fwrite(&((BinFile_DragonVert**)vertdatas)[i], swap_endian32(toc_meshes[i].vertdata_size), 1, fp);
    }

    // Write the animation TOCs
    for (i=0; i<list_animations.size; i++)
    {
        toc_anims[i].animdata_offset = swap_endian32(toc_anims[i].animdata_offset);
        toc_anims[i].animdata_size = swap_endian32(toc_anims[i].animdata_size);
        toc_anims[i].kfdata_offset = swap_endian32(toc_anims[i].kfdata_offset);
        toc_anims[i].kfdata_size = swap_endian32(toc_anims[i].kfdata_size);
        fwrite(&toc_anims[i].animdata_offset, member_size(BinFile_TOC_Anims, animdata_offset), 1, fp);
        fwrite(&toc_anims[i].animdata_size, member_size(BinFile_TOC_Anims, animdata_size), 1, fp);
        fwrite(&toc_anims[i].kfdata_offset, member_size(BinFile_TOC_Anims, kfdata_offset), 1, fp);
        fwrite(&toc_anims[i].kfdata_size, member_size(BinFile_TOC_Anims, kfdata_size), 1, fp);
    }

    // Write the anim data + keyframes
    for (i=0; i<list_animations.size; i++)
    {
        int j;
        for (j=0; j<animdatas[i].kfcount; j++)
            animdatas[i].kfindices[j] = swap_endian16(animdatas[i].kfindices[j]);
        animdatas[i].kfcount = swap_endian16(animdatas[i].kfcount);
        fwrite(&animdatas[i].kfcount, member_size(BinFile_AnimData, kfcount), 1, fp);
        fwrite(animdatas[i].kfindices, sizeof(uint16_t)*swap_endian16(animdatas[i].kfcount), 1, fp);
        fwrite(animdatas[i].name, strlen(animdatas[i].name)+1, 1, fp);
        for (j=0; j<kftotal[i]; j++)
        {
            kfdatas[i][j].pos[0] = swap_endianfloat(kfdatas[i][j].pos[0]);
            kfdatas[i][j].pos[1] = swap_endianfloat(kfdatas[i][j].pos[1]);
            kfdatas[i][j].pos[2] = swap_endianfloat(kfdatas[i][j].pos[2]);
            kfdatas[i][j].rot[0] = swap_endianfloat(kfdatas[i][j].rot[0]);
            kfdatas[i][j].rot[1] = swap_endianfloat(kfdatas[i][j].rot[1]);
            kfdatas[i][j].rot[2] = swap_endianfloat(kfdatas[i][j].rot[2]);
            kfdatas[i][j].rot[3] = swap_endianfloat(kfdatas[i][j].rot[3]);
            kfdatas[i][j].scale[0] = swap_endianfloat(kfdatas[i][j].scale[0]);
            kfdatas[i][j].scale[1] = swap_endianfloat(kfdatas[i][j].scale[1]);
            kfdatas[i][j].scale[2] = swap_endianfloat(kfdatas[i][j].scale[2]);
            fwrite(&kfdatas[i][j].pos[0], member_size(BinFile_KeyFrame, pos), 1, fp);
            fwrite(&kfdatas[i][j].rot[0], member_size(BinFile_KeyFrame, rot), 1, fp);
            fwrite(&kfdatas[i][j].scale[0], member_size(BinFile_KeyFrame, scale), 1, fp);
        }
    }
    fclose(fp);


    // -------------- Helper Header File --------------
    
    if (makestructs)
    {
        int tcount = 0;
        int longesttexname = 0;

        // Open the file
        sprintf(strbuff, "%s.h", global_outputname);
        fp = fopen(strbuff, "w+");
        if (fp == NULL)
            terminate("Error: Unable to open file for writing\n");

        // Print the header
        write_header(fp, makestructs);

        // Print texture count and texture list
        for (curnode = list_textures.head; curnode != NULL; curnode = curnode->next)
        {
            n64Texture* tex = (n64Texture*)curnode->data;
            if (get_validtexindex(&list_textures, tex->name) != -1)
            {
                int len = strlen(tex->name);
                tcount++;
                if (len > longesttexname)
                    longesttexname = len;
            }
        }
        if (tcount > 0)
        {
            fprintf(fp, "// Texture data\n#define TEXTURECOUNT_%s %d\n\n", global_modelname, tcount);
            for (curnode = list_textures.head; curnode != NULL; curnode = curnode->next)
            {
                int nspaces;
                n64Texture* tex = (n64Texture*)curnode->data;
                int tindex = get_validtexindex(&list_textures, tex->name);
                if (tindex != -1)
                {
                    fprintf(fp, "#define TEXTURE_%s ", tex->name);
                    nspaces = strlen(tex->name);
                    for (i=nspaces; i<longesttexname; i++) fputc(' ', fp);
                    fprintf(fp, "%d\n", tindex);
                }
            }
        }

        // Print the extern definitions
        if (!global_opengl)
        {
            fprintf(fp, "\n// Extern definitions\n");
            fprintf(fp, "extern u8 _%sSegmentRomStart[];\n", global_modelname);
            fprintf(fp, "extern u8 _%sSegmentRomEnd[];", global_modelname);
        }

        // Done
        fclose(fp);
    }

    // Finished writing the output
    if (!global_quiet)
    {
        printf("Wrote output to '%s.bin'", global_outputname);
        if (makestructs)
            printf(" and '%s.h'", global_outputname);
        printf("\n");
    }
}