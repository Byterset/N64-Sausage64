/***************************************************************
                           output.c
                             
Outputs the parsed data to a file
***************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>
#include "main.h"
#include "mesh.h"
#include "animation.h"
#include "dlist.h"
#include "opengl.h"

#define STRBUF_SIZE 512

#define member_size(type, member) (sizeof( ((type *)0)->member ))

typedef struct {
    char header[4];
    uint16_t count_meshes;
    uint16_t count_materials;
    uint16_t count_anims;
    uint16_t offset_meshes;
    uint32_t offset_materials;
    uint32_t offset_anims;
} BinFile;

typedef struct {
    uint32_t meshdata_offset;
    uint32_t meshdata_size;
    uint32_t vertdata_offset;
    uint32_t vertdata_size;
    uint32_t facedata_offset;
    uint32_t facedata_size;
    uint32_t dldata_offset;
    uint32_t dldata_size;
    uint32_t dldata_slotcount;
} BinFile_TOC_Meshes;

typedef struct {
    int16_t parent;
    uint8_t is_billboard;
    char*   name;
} BinFile_MeshData;

typedef struct {
    int16_t  pos[3];
    uint16_t pad;
    int16_t  tex[2];
    uint8_t  colornormal[4];
} BinFile_UltraVert;

typedef struct {
    float pos[3];
    float tex[2];
    float normal[3];
    float color[3];
} BinFile_DragonVert;

typedef struct {
    uint16_t vertcount;
    uint16_t vertoffset;
    uint16_t facecount;
    uint16_t faceoffset;
    int32_t matid;
} BinFile_VCacheRenderBlock;

typedef struct {
    uint32_t matdata_offset;
    uint32_t matdata_size;
    uint32_t material_offset;
    uint32_t material_size;
} BinFile_TOC_Materials;

typedef struct {
    uint8_t type;
    uint8_t lighting;
    uint8_t cullfront;
    uint8_t cullback;
    uint8_t smooth;
    uint8_t depthtest;
    char* name;
} BinFile_MatData;

typedef struct {
    uint32_t w;
    uint32_t h;
    uint32_t filter;
    uint16_t wraps;
    uint16_t wrapt;
} BinFile_Material_Texture;

typedef struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
} BinFile_Material_PrimColor;

typedef struct {
    uint32_t animdata_offset;
    uint32_t animdata_size;
    uint32_t kfdata_offset;
    uint32_t kfdata_size;
} BinFile_TOC_Anims;

typedef struct {
    uint32_t kfcount;
    uint16_t* kfindices;
    char* name;
} BinFile_AnimData;

typedef struct {
    float pos[3];
    float rot[4];
    float scale[3];
} BinFile_KeyFrame;


/*==============================
    align_32bits
    Aligns a number to 32 bits
    @param  The number to align
    @return The aligned value
==============================*/

static int align_32bits(int num)
{
    return ((num + (4 - 1))/4)*4;
}


/*==============================
    writepadding
    Write zero padding to a file
    @param The file to PAD
    @parma The number to align for padding
==============================*/

static void writepadding(FILE* fp, int padvalue)
{
    const uint8_t padbytes[4] = {0};
    int padding = align_32bits(padvalue) - padvalue;
    if (padding > 0)
        fwrite(padbytes, padding, 1, fp);
}


/*==============================
    write_header
    Writes the header data to a text file.
    @param The file pointer
    @param Whether to generate helper macros
==============================*/

static void write_header(FILE* fp, bool makemacros)
{
    int i;
    int count;
    listNode* curnode;
    int longestmeshname = 0, longestanimname = 0;
        
    // Find the mesh and animation with the longest name
    for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
    {
        s64Mesh* mesh = (s64Mesh*)curnode->data;
        int len = strlen(mesh->name);
        if (len > longestmeshname)
            longestmeshname = len;
    }
    for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
    {
        s64Anim* anim = (s64Anim*)curnode->data;
        int len = strlen(anim->name);
        if (len > longestanimname)
            longestanimname = len;
    }

    // Print the header
    fprintf(fp, "// Generated by "PROGRAM_NAME" V"PROGRAM_VERSION"\n");
    fprintf(fp, "// By Buu342\n\n");
    
    // Create some helper macros
    if (makemacros)
    {
        // Iterate through all the meshes and print their names
        count = 0;
        fprintf(fp, "// Mesh data\n#define MESHCOUNT_%s %d\n\n", global_modelname, list_meshes.size);
        for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
        {
            s64Mesh* mesh = (s64Mesh*)curnode->data;
            int nspaces = strlen(mesh->name);
            fprintf(fp, "#define MESH_%s_%s ", global_modelname, mesh->name);
            for (i=nspaces; i<longestmeshname; i++) fputc(' ', fp);
            fprintf(fp, "%d\n", count++);
        }
        fputs("\n", fp);
        
        // Iterate through all the animations and print their names
        count = 0;
        fprintf(fp, "// Animation data\n#define ANIMATIONCOUNT_%s %d\n\n", global_modelname, list_animations.size);
        for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
        {
            s64Anim* anim = (s64Anim*)curnode->data;
            int nspaces = strlen(anim->name);
            fprintf(fp, "#define ANIMATION_%s_%s ", global_modelname, anim->name);
            for (i=nspaces; i<longestanimname; i++) fputc(' ', fp);
            fprintf(fp, "%d\n", count++);
        }
        fputs("\n", fp);
    }
}


/*==============================
    write_output_text
    Writes the output to a text file
==============================*/

void write_output_text()
{
    int i;
    FILE* fp;
    FILE* fp_temp;
    listNode* curnode;
    int tempc;
    char strbuff[STRBUF_SIZE];
    bool makestructs = (list_animations.size > 0 || list_meshes.size > 1);

    // Open the file
    sprintf(strbuff, "%s.h", global_outputname);
    fp = fopen(strbuff, "w+");
    if (fp == NULL)
        terminate("Error: Unable to open file for writing\n");
        
    // Print the header
    write_header(fp, makestructs);

    // Construct a text display list
    if (!global_opengl)
        construct_dltext();
    else
        construct_opengl();
    
    // Dump our temporary file into our final file, and then remove it after we're done
    sprintf(strbuff, "temp_%s", global_outputname);
    fp_temp = fopen(strbuff, "r+");
    if (fp_temp == NULL)
        terminate("Error: Unable to open temporary file for reading\n");
    while ((tempc = fgetc(fp_temp)) != EOF)
       fputc(tempc, fp);
    fclose(fp_temp);
    remove(strbuff);
    
    // Write the animation data
    if (list_animations.size > 0)
    {
        fputs("\n", fp);
        fputs("/*********************************\n"
              "          Animation Data\n"
              "*********************************/", fp);
        for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
        {
            listNode* keyfnode;
            s64Anim* anim = (s64Anim*)curnode->data;
            fputs("\n\n", fp);
            
            // Print an array of framedata
            for (keyfnode = anim->keyframes.head; keyfnode != NULL; keyfnode = keyfnode->next)
            {
                listNode* meshnode;
                s64Keyframe* keyf = (s64Keyframe*)keyfnode->data;
                fprintf(fp, "static s64Transform anim_%s_%s_framedata%d[] = {\n", global_modelname, anim->name, keyf->keyframe);
                for (meshnode = list_meshes.head; meshnode != NULL; meshnode = meshnode->next) // Iterating meshes because they can be out of order to the frame data, due to material sorting optimization
                {
                    listNode* fdatanode;
                    for (fdatanode = keyf->framedata.head; fdatanode != NULL; fdatanode = fdatanode->next)
                    {
                        s64Transform* fdata = (s64Transform*)fdatanode->data;
                        if (meshnode->data == fdata->mesh)
                        {
                            fprintf(fp, "    {{%.4ff, %.4ff, %.4ff}, {%.4ff, %.4ff, %.4ff, %.4ff}, {%.4ff, %.4ff, %.4ff}},\n", 
                                fdata->translation.x, fdata->translation.y, fdata->translation.z,
                                fdata->rotation.w, fdata->rotation.x, fdata->rotation.y, fdata->rotation.z,
                                fdata->scale.x, fdata->scale.y, fdata->scale.z
                            );
                            break;
                        }
                    }
                }
                fprintf(fp, "};\n");
            }
            
            // Then print an array of keyframes
            fprintf(fp, "static s64KeyFrame anim_%s_%s_keyframes[] = {\n", global_modelname, anim->name);
            for (keyfnode = anim->keyframes.head; keyfnode != NULL; keyfnode = keyfnode->next)
            {
                s64Keyframe* keyf = (s64Keyframe*)keyfnode->data;
                fprintf(fp, "    {%d, anim_%s_%s_framedata%d},\n", keyf->keyframe, global_modelname, anim->name, keyf->keyframe);
            }
            fprintf(fp, "};");
        }
    }
    
    // Finally, print the Sausage64 structs
    if (makestructs)
    {
        bool ismultimesh = (list_meshes.size > 1);
        
        // Struct comment header
        fputs("\n\n\n", fp);
        fputs("/*********************************\n"
              "        Sausage64 Structs\n"
              "*********************************/\n", fp);
        fputs("\n", fp);
        
        // Mesh list
        fprintf(fp, "static s64Mesh meshes_%s[] = {\n", global_modelname);
        for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
        {
            bool billboard = FALSE;
            s64Mesh* mesh = (s64Mesh*)curnode->data;
            
            // Write the model data line
            fprintf(fp, "    {\"%s\", %d, ", mesh->name, has_property(mesh, "Billboard"));
            if (global_opengl)
                fputs("&", fp);
            if (ismultimesh)
                fprintf(fp, "gfx_%s_%s, ", global_modelname, mesh->name);
            else
                fprintf(fp, "gfx_%s, ", global_modelname);
            if (mesh->parent != NULL)
            {
                int index = 0;
                listNode* pnode;

                for (pnode = list_meshes.head; pnode != NULL; pnode = pnode->next)
                {
                    s64Mesh* parent = (s64Mesh*)pnode->data;
                    if (!strcmp(parent->name, mesh->parent))
                    {
                        fprintf(fp, "%d", index);
                        break;
                    }
                    index++;
                }
            }
            else
                fprintf(fp, "-1");

            fprintf(fp, "},\n");
        }
        fputs("};\n\n", fp);
        
        // Animation list
        fprintf(fp, "static s64Animation anims_%s[] = {\n", global_modelname);
        for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
        {
            s64Anim* anim = (s64Anim*)curnode->data;
            fprintf(fp, "    {\"%s\", %d, anim_%s_%s_keyframes},\n", anim->name, anim->keyframes.size, global_modelname, anim->name);
        }
        fputs("};\n\n", fp);

        // Final model data
        fprintf(fp, "static s64ModelData mdl_%s = {%d, %d, meshes_%s, anims_%s, NULL};", global_modelname, list_meshes.size, list_animations.size, global_modelname, global_modelname);
    }
    
    // Finish
    if (!global_quiet) printf("Wrote output to '%s.h'\n", global_outputname);
    fclose(fp);
}


/*==============================
    write_output_binary
    Writes the output to a binary file.
==============================*/

void write_output_binary()
{
    int i;
    FILE* fp;
    listNode* curnode;
    char strbuff[STRBUF_SIZE];
    BinFile bin;
    BinFile_TOC_Meshes* toc_meshes;
    BinFile_MeshData* meshdatas;
    void* vertdatas;
    int* vtotal;
    int* ftotal;
    uint16_t** facedatas;
    uint32_t** dldatas;
    BinFile_TOC_Anims* toc_anims;
    BinFile_AnimData* animdatas;
    BinFile_KeyFrame** kfdatas;
    int* kftotal;
    bool makestructs = (list_animations.size > 0 || list_meshes.size > 1);
    int texturecount = 0, primcolorcount = 0;
    int longesttexname = 0;
    BinFile_TOC_Materials* toc_materials;
    BinFile_MatData* matdatas;
    BinFile_Material_Texture* textures;
    BinFile_Material_PrimColor* primcolors;
    
    // Open the file
    sprintf(strbuff, "%s.bin", global_outputname);
    fp = fopen(strbuff, "wb+");
    if (fp == NULL)
        terminate("Error: Unable to open file for writing\n");
    
    // Generate the file header
    bin.header[0]     = 'S';
    bin.header[1]     = '6';
    bin.header[2]     = '4';
    bin.header[3]     = BINARY_VERSION;
    bin.count_meshes  = list_meshes.size;
    bin.count_materials = 0;
    bin.count_anims   = list_animations.size;
    if (global_opengl)
    {
        for (curnode = list_materials.head; curnode != NULL; curnode = curnode->next)
        {
            n64Material* mat = (n64Material*)curnode->data;
            if (isvalidmat(mat))
                bin.count_materials++;
        }
    }

    // Malloc stuff
    toc_meshes = (BinFile_TOC_Meshes*)malloc(sizeof(BinFile_TOC_Meshes)*list_meshes.size);
    meshdatas = (BinFile_MeshData*)malloc(sizeof(BinFile_MeshData)*list_meshes.size);
    if (!global_opengl)
        vertdatas = (BinFile_UltraVert**)malloc(sizeof(BinFile_UltraVert*)*list_meshes.size);
    else
        vertdatas = (BinFile_DragonVert**)malloc(sizeof(BinFile_DragonVert*)*list_meshes.size);
    facedatas = (uint16_t**)malloc(sizeof(uint16_t*)*list_meshes.size);
    dldatas = (uint32_t**)malloc(sizeof(uint32_t*)*list_meshes.size);
    vtotal = (int*)malloc(sizeof(int)*list_meshes.size);
    ftotal = (int*)malloc(sizeof(int)*list_meshes.size);
    kftotal = (int*)malloc(sizeof(int)*list_animations.size);
    kfdatas = (BinFile_KeyFrame**)malloc(sizeof(BinFile_KeyFrame*)*list_animations.size);
    if (toc_meshes == NULL || meshdatas == NULL || vertdatas == NULL || facedatas == NULL || dldatas == NULL || vtotal == NULL || ftotal == NULL || kftotal == NULL || kfdatas == NULL)
        terminate("Error: Malloc failure during binary output\n");


    // -------------- Mesh Data --------------

    i = 0;
    for (curnode = list_meshes.head; curnode != NULL; curnode = curnode->next)
    {
        int parent = 0;
        listNode* vcachenode;
        s64Mesh* mesh = (s64Mesh*)curnode->data;

        // Find the parent mesh
        if (mesh->parent != NULL)
        {
            listNode* pnode;
            for (pnode = list_meshes.head; pnode != NULL; pnode = pnode->next)
            {
                s64Mesh* p = (s64Mesh*)pnode->data;
                if (!strcmp(p->name, mesh->parent))
                    break;
                parent++;
            }
        }
        else
            parent = -1;

        // Assign the meshdata
        meshdatas[i].parent = parent;
        meshdatas[i].is_billboard = has_property(mesh, "Billboard");
        meshdatas[i].name = mesh->name;
 
        // Update the mesh data size and offset
        toc_meshes[i].meshdata_size = member_size(BinFile_MeshData, parent) 
                                    + member_size(BinFile_MeshData, is_billboard)
                                    + strlen(meshdatas[i].name)+1;
        if (i == 0)
        {
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, meshdata_offset);
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, meshdata_size);
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, vertdata_offset);
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, vertdata_size);
            if (global_opengl)
            {
                toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, facedata_offset);
                toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, facedata_size);
            }
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, dldata_offset);
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, dldata_size);
            toc_meshes[i].meshdata_offset += member_size(BinFile_TOC_Meshes, dldata_slotcount);
            toc_meshes[i].meshdata_offset *= list_meshes.size;
            toc_meshes[i].meshdata_offset += member_size(BinFile, header) ;
            toc_meshes[i].meshdata_offset += member_size(BinFile, count_materials);
            toc_meshes[i].meshdata_offset += member_size(BinFile, count_meshes);
            toc_meshes[i].meshdata_offset += member_size(BinFile, count_anims);
            toc_meshes[i].meshdata_offset += member_size(BinFile, offset_meshes);
            toc_meshes[i].meshdata_offset += member_size(BinFile, offset_anims);
            toc_meshes[i].meshdata_offset += member_size(BinFile, offset_materials);
        }
        else
            toc_meshes[i].meshdata_offset = toc_meshes[i-1].dldata_offset + toc_meshes[i-1].dldata_size;

        // Get the total vert and face count
        vtotal[i] = 0;
        for (vcachenode = mesh->vertcache.head; vcachenode != NULL; vcachenode = vcachenode->next)
        {
            vertCache* vcache = (vertCache*)vcachenode->data;
            listNode* vertnode;
            
            // Cycle through all the verts
            for (vertnode = vcache->verts.head; vertnode != NULL; vertnode = vertnode->next)
                vtotal[i]++;
            for (vertnode = vcache->faces.head; vertnode != NULL; vertnode = vertnode->next)
                ftotal[i]++;
        }

        // Create the vert data
        if (!global_opengl)
        {
            int j = 0;

            ((BinFile_UltraVert**)vertdatas)[i] = (BinFile_UltraVert*)malloc(sizeof(BinFile_UltraVert)*vtotal[i]);
            if (((BinFile_UltraVert**)vertdatas)[i] == NULL)
                terminate("Error: Unable to malloc for vert data\n");

            // Copy the vert data by cycling through the vcache blocks
            for (vcachenode = mesh->vertcache.head; vcachenode != NULL; vcachenode = vcachenode->next)
            {
                vertCache* vcache = (vertCache*)vcachenode->data;
                listNode* vertnode;
                
                // Cycle through all the verts
                for (vertnode = vcache->verts.head; vertnode != NULL; vertnode = vertnode->next)
                {
                    int texturew = 0, textureh = 0;
                    s64Vert* vert = (s64Vert*)vertnode->data;
                    n64Material* mat = find_material_fromvert(&vcache->faces, vert);
                    Vector3D normorcol = {0, 0, 0};
                    
                    // Ensure the texture is valid
                    if (mat == NULL)
                        terminate("Error: Inconsistent face/vertex material information\n");
                    
                    // Retrieve texture/normal/color data for this vertex
                    switch (mat->type)
                    {
                        case TYPE_TEXTURE:
                            // Get the texture size
                            texturew = (mat->data).image.w;
                            textureh = (mat->data).image.h;
                            
                            // Intentional fallthrough
                        case TYPE_PRIMCOL:
                            // Pick vertex normals or vertex colors, depending on the texture flag
                            if (mat_hasgeoflag(mat, "G_LIGHTING"))
                                normorcol = vector_scale(vert->normal, 127);
                            else
                                normorcol = vector_scale(vert->color, 255);
                            break;
                        case TYPE_OMIT:
                            break;
                    }

                    // Dump the vert data
                    ((BinFile_UltraVert**)vertdatas)[i][j].pos[0] = round(vert->pos.x);
                    ((BinFile_UltraVert**)vertdatas)[i][j].pos[1] = round(vert->pos.y);
                    ((BinFile_UltraVert**)vertdatas)[i][j].pos[2] = round(vert->pos.z);
                    ((BinFile_UltraVert**)vertdatas)[i][j].pad = 0;
                    ((BinFile_UltraVert**)vertdatas)[i][j].tex[0] = float_to_s10p5(vert->UV.x*texturew);
                    ((BinFile_UltraVert**)vertdatas)[i][j].tex[1] = float_to_s10p5(vert->UV.y*textureh);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[0] = round(normorcol.x);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[1] = round(normorcol.y);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[2] = round(normorcol.z);
                    ((BinFile_UltraVert**)vertdatas)[i][j].colornormal[3] = 255;
                    j++;
                }
            }

            // Update the vert data size and offset in the TOC
            toc_meshes[i].vertdata_size = (member_size(BinFile_UltraVert, pos)
                                        + member_size(BinFile_UltraVert, pad) 
                                        + member_size(BinFile_UltraVert, tex)
                                        + member_size(BinFile_UltraVert, colornormal)
                                        )*vtotal[i];
        }
        else
        {
            int j = 0;

            ((BinFile_DragonVert**)vertdatas)[i] = (BinFile_DragonVert*)malloc(sizeof(BinFile_DragonVert)*vtotal[i]);
            if (((BinFile_DragonVert**)vertdatas)[i] == NULL)
                terminate("Error: Unable to malloc for vert data\n");

            for (vcachenode = mesh->vertcache.head; vcachenode != NULL; vcachenode = vcachenode->next)
            {
                listNode* vertnode;
                vertCache* vcache = (vertCache*)vcachenode->data;
                
                // Cycle through all the verts
                for (vertnode = vcache->verts.head; vertnode != NULL; vertnode = vertnode->next)
                {
                    s64Vert* vert = (s64Vert*)vertnode->data;
                    
                    // Dump the vert data
                    ((BinFile_DragonVert**)vertdatas)[i][j].pos[0] = swap_endianfloat(vert->pos.x);
                    ((BinFile_DragonVert**)vertdatas)[i][j].pos[1] = swap_endianfloat(vert->pos.y);
                    ((BinFile_DragonVert**)vertdatas)[i][j].pos[2] = swap_endianfloat(vert->pos.z);
                    ((BinFile_DragonVert**)vertdatas)[i][j].tex[0] = swap_endianfloat(vert->UV.x);
                    ((BinFile_DragonVert**)vertdatas)[i][j].tex[1] = swap_endianfloat(vert->UV.y);
                    ((BinFile_DragonVert**)vertdatas)[i][j].normal[0] = swap_endianfloat(vert->normal.x);
                    ((BinFile_DragonVert**)vertdatas)[i][j].normal[1] = swap_endianfloat(vert->normal.y);
                    ((BinFile_DragonVert**)vertdatas)[i][j].normal[2] = swap_endianfloat(vert->normal.z);
                    ((BinFile_DragonVert**)vertdatas)[i][j].color[0] = swap_endianfloat(vert->color.x);
                    ((BinFile_DragonVert**)vertdatas)[i][j].color[1] = swap_endianfloat(vert->color.y);
                    ((BinFile_DragonVert**)vertdatas)[i][j].color[2] = swap_endianfloat(vert->color.z);
                    j++;
                }
            }

            // Update the vert data size and offset in the TOC
            toc_meshes[i].vertdata_size = (member_size(BinFile_DragonVert, pos)
                                        + member_size(BinFile_DragonVert, tex)
                                        + member_size(BinFile_DragonVert, normal) 
                                        + member_size(BinFile_DragonVert, color)
                                        )*vtotal[i];
        }
        toc_meshes[i].vertdata_offset = toc_meshes[i].meshdata_offset + align_32bits(toc_meshes[i].meshdata_size);

        // Create the faces list (OpenGL)
        if (global_opengl)
        {
            int vertindex = 0;
            int faceindex = 0;

            // Malloc the face data
            facedatas[i] = (uint16_t*)malloc(sizeof(uint16_t)*ftotal[i]*3);
            if (facedatas[i] == NULL)
                terminate("Error: Unable to malloc for face data\n");

            // Assign the face data
            for (vcachenode = mesh->vertcache.head; vcachenode != NULL; vcachenode = vcachenode->next)
            {
                listNode* vertnode;
                vertCache* vcache = (vertCache*)vcachenode->data;
                
                // Cycle through all the faces
                for (vertnode = vcache->faces.head; vertnode != NULL; vertnode = vertnode->next)
                {
                    s64Face* face = (s64Face*)vertnode->data;
                    facedatas[i][faceindex*3 + 0] = swap_endian16(vertindex + list_index_from_data(&vcache->verts, face->verts[0]));
                    facedatas[i][faceindex*3 + 1] = swap_endian16(vertindex + list_index_from_data(&vcache->verts, face->verts[1]));
                    facedatas[i][faceindex*3 + 2] = swap_endian16(vertindex + list_index_from_data(&vcache->verts, face->verts[2]));
                    faceindex++;
                }
                vertindex += vcache->verts.size;
            }

            // Update the vert data size and offset in the TOC
            toc_meshes[i].facedata_size = sizeof(uint16_t)*ftotal[i]*3;
            toc_meshes[i].facedata_offset = toc_meshes[i].vertdata_offset + toc_meshes[i].vertdata_size;
        }

        // Create the display list
        if (!global_opengl)
        {
            int offset = 0;
            int finalsize = 0;
            int slotcount = 0;
            listNode* dllnode;
            linkedList* dllist = dlist_frommesh(mesh, TRUE);

            // Count the finalsize and slotcount
            for (dllnode = dllist->head; dllnode != NULL; dllnode = dllnode->next)
            {
                DLCBinary* bindl = (DLCBinary*)dllnode->data;
                finalsize += (1 + bindl->size)*sizeof(uint32_t);
                slotcount += commands_f3dex2[bindl->cmd].size;
            }

            // Update the TOC
            toc_meshes[i].dldata_size = finalsize;
            toc_meshes[i].dldata_slotcount = slotcount;
            toc_meshes[i].dldata_offset = toc_meshes[i].vertdata_offset + toc_meshes[i].vertdata_size;

            // Malloc the final data buffer
            dldatas[i] = (uint32_t*)calloc(finalsize, 1);
            if (dldatas[i] == NULL)
                terminate("Error: Unable to malloc for DLData\n");

            // Copy the binary list to the final data buffer
            for (dllnode = dllist->head; dllnode != NULL; dllnode = dllnode->next)
            {
                DLCBinary* bindl = (DLCBinary*)dllnode->data;
                dldatas[i][offset] = swap_endian32(bindl->cmd);
                offset++;
                memcpy(&dldatas[i][offset], bindl->data, sizeof(uint32_t)*bindl->size);
                offset += bindl->size;
            }

            // Cleanup memory
            for (dllnode = dllist->head; dllnode != NULL; dllnode = dllnode->next)
                free(((DLCBinary*)dllnode->data)->data);
            list_destroy_deep(dllist);
        }
        else
        {
            int j=0;
            linkedList* list_vcacherender = generate_opengl_vcachelist(mesh);

            // Copy our data to the dldata block
            dldatas[i] = (uint32_t*)malloc(sizeof(uint32_t)*3*list_vcacherender->size);
            if (dldatas[i] == NULL)
                terminate("Error: Unable to malloc for DLData\n");
            for (vcachenode = list_vcacherender->head; vcachenode != NULL; vcachenode = vcachenode->next)
            {
                VCacheRenderBlock* vcrb = vcachenode->data;
                dldatas[i][j*3 + 0] = ((swap_endian16(vcrb->vertoffset) << 16) & 0xFFFF0000) | (swap_endian16(vcrb->vertcount) & 0x0000FFFF);
                dldatas[i][j*3 + 1] = ((swap_endian16(vcrb->faceoffset) << 16) & 0xFFFF0000) | (swap_endian16(vcrb->facecount) & 0x0000FFFF);
                dldatas[i][j*3 + 2] = swap_endian32(vcrb->matid);
                j++;
            }

            // Fill in the dldata info
            toc_meshes[i].dldata_size = (member_size(VCacheRenderBlock, vertcount)
                                    + member_size(VCacheRenderBlock, vertoffset)
                                    + member_size(VCacheRenderBlock, facecount)
                                    + member_size(VCacheRenderBlock, faceoffset)
                                    + member_size(VCacheRenderBlock, matid))
                                    *list_vcacherender->size;
            toc_meshes[i].dldata_slotcount = list_vcacherender->size;
            toc_meshes[i].dldata_offset = toc_meshes[i].facedata_offset + align_32bits(toc_meshes[i].facedata_size);

            // Cleanup
            list_destroy_deep(list_vcacherender);
            free(list_vcacherender);
        }

        // Done
        i++;
    }


    // -------------- Material Data (OpenGL) --------------

    if (bin.count_materials > 0)
    {
        int j, k;
        bin.offset_materials = toc_meshes[list_meshes.size-1].dldata_offset + toc_meshes[list_meshes.size-1].dldata_size;
        toc_materials = (BinFile_TOC_Materials*)malloc(sizeof(BinFile_TOC_Materials)*bin.count_materials);
        matdatas = (BinFile_MatData*)malloc(sizeof(BinFile_MatData)*bin.count_materials);
        if (toc_materials == NULL || matdatas == NULL)
            terminate("Error: Unable to malloc for material data");

        // Count the type of each material, and fill in the matdatas
        i=0;
        for (curnode = list_materials.head; curnode != NULL; curnode = curnode->next)
        {
            n64Material* mat = (n64Material*)curnode->data;
            if (!isvalidmat(mat))
                continue;
            matdatas[i].type = mat->type;
            matdatas[i].lighting = mat_hasgeoflag(mat, "G_LIGHTING");
            matdatas[i].cullfront = mat_hasgeoflag(mat, "G_CULL_FRONT");
            matdatas[i].cullback = mat_hasgeoflag(mat, "G_CULL_BACK");
            matdatas[i].smooth = mat_hasgeoflag(mat, "G_SHADING_SMOOTH");
            matdatas[i].depthtest = mat_hasgeoflag(mat, "G_ZBUFFER");
            matdatas[i].name = mat->name;
            switch (mat->type)
            {
                case TYPE_TEXTURE: texturecount++; break;
                case TYPE_PRIMCOL: primcolorcount++; break;
            }
            toc_materials[i].matdata_size = member_size(BinFile_MatData, type)
                                          + member_size(BinFile_MatData, lighting)
                                          + member_size(BinFile_MatData, cullfront)
                                          + member_size(BinFile_MatData, cullback)
                                          + member_size(BinFile_MatData, smooth)
                                          + member_size(BinFile_MatData, depthtest)
                                          + (strlen(mat->name) + 1);
            i++;
        }

        // Malloc the material structs
        textures = (BinFile_Material_Texture*)malloc(sizeof(BinFile_Material_Texture)*texturecount);
        primcolors = (BinFile_Material_PrimColor*)malloc(sizeof(BinFile_Material_PrimColor)*primcolorcount);
        if ((texturecount > 0 && textures == NULL) || (primcolorcount > 0 && primcolors == NULL))
            terminate("Error: Unable to malloc for material data");

        // Fill in the material structs
        i=0;
        j=0;
        k=0;
        for (curnode = list_materials.head; curnode != NULL; curnode = curnode->next)
        {
            n64Material* mat = (n64Material*)curnode->data;
            if (!isvalidmat(mat))
                continue;
            switch (mat->type)
            {
                case TYPE_TEXTURE:
                    textures[j].w = swap_endian32(mat->data.image.w);
                    textures[j].h = swap_endian32(mat->data.image.h);
                    if (!strcmp(mat->texfilter, "G_TF_POINT"))
                        textures[j].filter = swap_endian32(0x2600);
                    else
                        textures[j].filter = swap_endian32(0x2601);
                    if (!strcmp(mat->data.image.texmodes, "G_TX_MIRROR"))
                        textures[j].wraps = swap_endian16(0x8370);
                    else if (!strcmp(mat->data.image.texmodes, "G_TX_WRAP"))
                        textures[j].wraps = swap_endian16(0x2901);
                    else
                        textures[j].wraps = swap_endian16(0x2900);
                    if (!strcmp(mat->data.image.texmodet, "G_TX_MIRROR"))
                        textures[j].wrapt = swap_endian16(0x8370);
                    else if (!strcmp(mat->data.image.texmodet, "G_TX_WRAP"))
                        textures[j].wrapt = swap_endian16(0x2901);
                    else
                        textures[j].wrapt = swap_endian16(0x2900);
                    toc_materials[i].material_size = member_size(BinFile_Material_Texture, w)
                                                   + member_size(BinFile_Material_Texture, h)
                                                   + member_size(BinFile_Material_Texture, filter)
                                                   + member_size(BinFile_Material_Texture, wraps);
                                                   + member_size(BinFile_Material_Texture, wrapt);
                    j++;
                    break;
                case TYPE_PRIMCOL:
                    primcolors[k].r = mat->data.color.r;
                    primcolors[k].g = mat->data.color.g;
                    primcolors[k].b = mat->data.color.b;
                    primcolors[k].a = 255;
                    toc_materials[i].material_size = member_size(BinFile_Material_PrimColor, r)
                                                   + member_size(BinFile_Material_PrimColor, g)
                                                   + member_size(BinFile_Material_PrimColor, b)
                                                   + member_size(BinFile_Material_PrimColor, a);
                    k++;
                    break;
                default:
                    terminate("Error: Unknown material type");
                    break;
            }

            // Finish assigning the offsets
            if (i == 0)
                toc_materials[i].matdata_offset = align_32bits(
                                                (member_size(BinFile_TOC_Materials, matdata_offset)
                                                + member_size(BinFile_TOC_Materials, matdata_size)
                                                + member_size(BinFile_TOC_Materials, material_offset)
                                                + member_size(BinFile_TOC_Materials, material_size))
                                                * bin.count_materials
                                                + toc_meshes[list_meshes.size-1].dldata_offset 
                                                + toc_meshes[list_meshes.size-1].dldata_size);
            else
                toc_materials[i].matdata_offset = toc_materials[i-1].material_offset + align_32bits(toc_materials[i-1].material_size);
            toc_materials[i].material_offset = toc_materials[i].matdata_offset + align_32bits(toc_materials[i].matdata_size);
            i++;
        }
    }


    // -------------- Animation Data --------------

    // Update the header's animation offset
    if (bin.count_materials == 0)
    {
        bin.offset_anims = toc_meshes[list_meshes.size-1].dldata_offset + toc_meshes[list_meshes.size-1].dldata_size;
        bin.offset_materials = bin.offset_anims;
    }
    else
        bin.offset_anims = toc_materials[bin.count_materials-1].material_offset + toc_materials[bin.count_materials-1].material_size;

    // Create the animation TOC
    toc_anims = (BinFile_TOC_Anims*)malloc(sizeof(BinFile_TOC_Anims)*list_animations.size);
    animdatas = (BinFile_AnimData*)malloc(sizeof(BinFile_AnimData)*list_animations.size);
    if (toc_anims == NULL || animdatas == NULL)
        terminate("Error: Unable to malloc for Anim Data\n");
    i = 0;
    for (curnode = list_animations.head; curnode != NULL; curnode = curnode->next)
    {
        int j=0;
        listNode* kfnode;
        listNode* meshnode;
        s64Anim* anim = (s64Anim*)curnode->data;

        // Assign the animdatas
        animdatas[i].kfcount = anim->keyframes.size;
        animdatas[i].kfindices = (uint16_t*)malloc(sizeof(uint16_t)*anim->keyframes.size);
        if (animdatas[i].kfindices == NULL)
            terminate("Error: Unable to malloc for AnimData kfindices\n");
        for (kfnode = anim->keyframes.head; kfnode != NULL; kfnode = kfnode->next)
            animdatas[i].kfindices[j++] = ((s64Keyframe*)kfnode->data)->keyframe;
        animdatas[i].name = anim->name;

        // Assign some keyframe data
        kftotal[i] = animdatas[i].kfcount*list_meshes.size;
        for (kfnode = anim->keyframes.head; kfnode != NULL; kfnode = kfnode->next)
        {
            kfdatas[i] = (BinFile_KeyFrame*)malloc(sizeof(BinFile_KeyFrame)*kftotal[i]);
            if (kfdatas[i] == NULL)
                terminate("Error: Unable to malloc for AnimData kfdatas\n");
        }

        // Update the anim data size and offset
        toc_anims[i].animdata_size = member_size(BinFile_AnimData, kfcount) 
                                    + (sizeof(uint16_t)*animdatas[i].kfcount)
                                    + strlen(animdatas[i].name)+1;
        if (i == 0)
            toc_anims[i].animdata_offset = bin.offset_anims +
                                            (member_size(BinFile_TOC_Anims, animdata_offset) +
                                            member_size(BinFile_TOC_Anims, animdata_size) +
                                            member_size(BinFile_TOC_Anims, kfdata_offset) +
                                            member_size(BinFile_TOC_Anims, kfdata_size))
                                            *list_animations.size;
        else
            toc_anims[i].animdata_offset = toc_anims[i-1].kfdata_offset + toc_anims[i-1].kfdata_size;
        toc_anims[i].kfdata_size = (member_size(BinFile_KeyFrame, pos) + member_size(BinFile_KeyFrame, rot) + member_size(BinFile_KeyFrame, scale))*animdatas[i].kfcount*list_meshes.size;
        toc_anims[i].kfdata_offset = toc_anims[i].animdata_offset + align_32bits(toc_anims[i].animdata_size);
        j=0;
        for (kfnode = anim->keyframes.head; kfnode != NULL; kfnode = kfnode->next)
        {
            s64Keyframe* keyf = (s64Keyframe*)kfnode->data;
            for (meshnode = list_meshes.head; meshnode != NULL; meshnode = meshnode->next) // Iterating meshes because they can be out of order to the frame data, due to material sorting optimization
            {
                listNode* fdatanode;
                for (fdatanode = keyf->framedata.head; fdatanode != NULL; fdatanode = fdatanode->next)
                {
                    s64Transform* fdata = (s64Transform*)fdatanode->data;
                    if (meshnode->data == fdata->mesh)
                    {
                        kfdatas[i][j].pos[0] = fdata->translation.x;
                        kfdatas[i][j].pos[1] = fdata->translation.y;
                        kfdatas[i][j].pos[2] = fdata->translation.z;
                        kfdatas[i][j].rot[0] = fdata->rotation.w;
                        kfdatas[i][j].rot[1] = fdata->rotation.x;
                        kfdatas[i][j].rot[2] = fdata->rotation.y;
                        kfdatas[i][j].rot[3] = fdata->rotation.z;
                        kfdatas[i][j].scale[0] = fdata->scale.x;
                        kfdatas[i][j].scale[1] = fdata->scale.y;
                        kfdatas[i][j].scale[2] = fdata->scale.z;
                        j++;
                        break;
                    }
                }
            }
        }

        // Done
        i++;
    }


    // -------------- Actually start writing the binary file now --------------

    // Write the file header
    bin.count_meshes      = swap_endian16(bin.count_meshes);
    bin.count_materials   = swap_endian16(bin.count_materials);
    bin.count_anims       = swap_endian16(bin.count_anims);
    bin.offset_meshes     = swap_endian16(0x14);
    bin.offset_materials  = swap_endian32(bin.offset_materials);
    bin.offset_anims      = swap_endian32(bin.offset_anims);
    fwrite(&bin.header, member_size(BinFile, header), 1, fp);
    fwrite(&bin.count_meshes, member_size(BinFile, count_meshes), 1, fp);
    fwrite(&bin.count_materials, member_size(BinFile, count_materials), 1, fp);
    fwrite(&bin.count_anims, member_size(BinFile, count_anims), 1, fp);
    fwrite(&bin.offset_meshes, member_size(BinFile, offset_meshes), 1, fp);
    fwrite(&bin.offset_materials, member_size(BinFile, offset_materials), 1, fp);
    fwrite(&bin.offset_anims, member_size(BinFile, offset_anims), 1, fp);

    // Write the mesh TOCs
    for (i=0; i<list_meshes.size; i++)
    {
        toc_meshes[i].meshdata_offset = swap_endian32(toc_meshes[i].meshdata_offset);
        toc_meshes[i].meshdata_size = swap_endian32(toc_meshes[i].meshdata_size);
        toc_meshes[i].vertdata_offset = swap_endian32(toc_meshes[i].vertdata_offset);
        toc_meshes[i].vertdata_size = swap_endian32(toc_meshes[i].vertdata_size);
        toc_meshes[i].dldata_offset = swap_endian32(toc_meshes[i].dldata_offset);
        toc_meshes[i].dldata_size = swap_endian32(toc_meshes[i].dldata_size);
        toc_meshes[i].dldata_slotcount = swap_endian32(toc_meshes[i].dldata_slotcount);
        fwrite(&toc_meshes[i].meshdata_offset, member_size(BinFile_TOC_Meshes, meshdata_offset), 1, fp);
        fwrite(&toc_meshes[i].meshdata_size, member_size(BinFile_TOC_Meshes, meshdata_size), 1, fp);
        fwrite(&toc_meshes[i].vertdata_offset, member_size(BinFile_TOC_Meshes, vertdata_offset), 1, fp);
        fwrite(&toc_meshes[i].vertdata_size, member_size(BinFile_TOC_Meshes, vertdata_size), 1, fp);
        if (global_opengl)
        {
            toc_meshes[i].facedata_offset = swap_endian32(toc_meshes[i].facedata_offset);
            toc_meshes[i].facedata_size = swap_endian32(toc_meshes[i].facedata_size);
            fwrite(&toc_meshes[i].facedata_offset, member_size(BinFile_TOC_Meshes, facedata_offset), 1, fp);
            fwrite(&toc_meshes[i].facedata_size, member_size(BinFile_TOC_Meshes, facedata_size), 1, fp);
        }
        fwrite(&toc_meshes[i].dldata_offset, member_size(BinFile_TOC_Meshes, dldata_offset), 1, fp);
        fwrite(&toc_meshes[i].dldata_size, member_size(BinFile_TOC_Meshes, dldata_size), 1, fp);
        fwrite(&toc_meshes[i].dldata_slotcount, member_size(BinFile_TOC_Meshes, dldata_slotcount), 1, fp);
    }

    // Write the mesh data + verts + faces + dl
    for (i=0; i<list_meshes.size; i++)
    {
        int j;
        meshdatas[i].parent = swap_endian16(meshdatas[i].parent);
        fwrite(&meshdatas[i].parent, member_size(BinFile_MeshData, parent), 1, fp);
        fwrite(&meshdatas[i].is_billboard, member_size(BinFile_MeshData, is_billboard), 1, fp);
        fwrite(meshdatas[i].name, strlen(meshdatas[i].name)+1, 1, fp);
        writepadding(fp, swap_endian32(toc_meshes[i].meshdata_size));
        if (!global_opengl)
        {
            for (j=0; j<vtotal[i]; j++)
            {
                ((BinFile_UltraVert**)vertdatas)[i][j].pos[0] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pos[0]);
                ((BinFile_UltraVert**)vertdatas)[i][j].pos[1] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pos[1]);
                ((BinFile_UltraVert**)vertdatas)[i][j].pos[2] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pos[2]);
                ((BinFile_UltraVert**)vertdatas)[i][j].pad = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].pad);
                ((BinFile_UltraVert**)vertdatas)[i][j].tex[0] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].tex[0]);
                ((BinFile_UltraVert**)vertdatas)[i][j].tex[1] = swap_endian16(((BinFile_UltraVert**)vertdatas)[i][j].tex[1]);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].pos[0], member_size(BinFile_UltraVert, pos), 1, fp);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].pad, member_size(BinFile_UltraVert, pad), 1, fp);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].tex[0], member_size(BinFile_UltraVert, tex), 1, fp);
                fwrite(&((BinFile_UltraVert**)vertdatas)[i][j].colornormal[0], member_size(BinFile_UltraVert, colornormal), 1, fp);
            }
        }
        else
        {
            for (j=0; j<vtotal[i]; j++)
            {
                fwrite(&((BinFile_DragonVert**)vertdatas)[i][j].pos[0], member_size(BinFile_DragonVert, pos), 1, fp);
                fwrite(&((BinFile_DragonVert**)vertdatas)[i][j].tex[0], member_size(BinFile_DragonVert, tex), 1, fp);
                fwrite(&((BinFile_DragonVert**)vertdatas)[i][j].normal[0], member_size(BinFile_DragonVert, normal), 1, fp);
                fwrite(&((BinFile_DragonVert**)vertdatas)[i][j].color[0], member_size(BinFile_DragonVert, color), 1, fp);
            }
            for (j=0; j<ftotal[i]; j++)
                fwrite(&facedatas[i][j*3], sizeof(uint16_t), 3, fp);
            writepadding(fp, swap_endian32(toc_meshes[i].facedata_size));
        }
        fwrite(dldatas[i], swap_endian32(toc_meshes[i].dldata_size), 1, fp);
    }

    // Write the material TOCs
    for (i=0; i<swap_endian16(bin.count_materials); i++)
    {
        toc_materials[i].matdata_offset = swap_endian32(toc_materials[i].matdata_offset);
        toc_materials[i].matdata_size = swap_endian32(toc_materials[i].matdata_size);
        toc_materials[i].material_offset = swap_endian32(toc_materials[i].material_offset);
        toc_materials[i].material_size = swap_endian32(toc_materials[i].material_size);
        fwrite(&toc_materials[i].matdata_offset, member_size(BinFile_TOC_Materials, matdata_offset), 1, fp);
        fwrite(&toc_materials[i].matdata_size, member_size(BinFile_TOC_Materials, matdata_size), 1, fp);
        fwrite(&toc_materials[i].material_offset, member_size(BinFile_TOC_Materials, material_offset), 1, fp);
        fwrite(&toc_materials[i].material_size, member_size(BinFile_TOC_Materials, material_size), 1, fp);
    }

    // Write the material data itself
    texturecount = 0;
    primcolorcount = 0;
    for (i=0; i<swap_endian16(bin.count_materials); i++)
    {
        fwrite(&matdatas[i].type, member_size(BinFile_MatData, type), 1, fp);
        fwrite(&matdatas[i].lighting, member_size(BinFile_MatData, lighting), 1, fp);
        fwrite(&matdatas[i].cullfront, member_size(BinFile_MatData, cullfront), 1, fp);
        fwrite(&matdatas[i].cullback, member_size(BinFile_MatData, cullback), 1, fp);
        fwrite(&matdatas[i].smooth, member_size(BinFile_MatData, smooth), 1, fp);
        fwrite(&matdatas[i].depthtest, member_size(BinFile_MatData, depthtest), 1, fp);
        fwrite(matdatas[i].name, strlen(matdatas[i].name)+1, 1, fp);
        writepadding(fp, swap_endian32(toc_materials[i].matdata_size));
        switch (matdatas[i].type)
        {
            case TYPE_TEXTURE:
                fwrite(&textures[texturecount].w, member_size(BinFile_Material_Texture, w), 1, fp);
                fwrite(&textures[texturecount].h, member_size(BinFile_Material_Texture, h), 1, fp);
                fwrite(&textures[texturecount].filter, member_size(BinFile_Material_Texture, filter), 1, fp);
                fwrite(&textures[texturecount].wraps, member_size(BinFile_Material_Texture, wraps), 1, fp);
                fwrite(&textures[texturecount].wrapt, member_size(BinFile_Material_Texture, wrapt), 1, fp);
                texturecount++;
                break;
            case TYPE_PRIMCOL:
                fwrite(&primcolors[primcolorcount].r, member_size(BinFile_Material_PrimColor, r), 1, fp);
                fwrite(&primcolors[primcolorcount].g, member_size(BinFile_Material_PrimColor, g), 1, fp);
                fwrite(&primcolors[primcolorcount].b, member_size(BinFile_Material_PrimColor, b), 1, fp);
                fwrite(&primcolors[primcolorcount].a, member_size(BinFile_Material_PrimColor, a), 1, fp);
                primcolorcount++;
                break;
        }
    }

    // Write the animation TOCs
    for (i=0; i<list_animations.size; i++)
    {
        toc_anims[i].animdata_offset = swap_endian32(toc_anims[i].animdata_offset);
        toc_anims[i].animdata_size = swap_endian32(toc_anims[i].animdata_size);
        toc_anims[i].kfdata_offset = swap_endian32(toc_anims[i].kfdata_offset);
        toc_anims[i].kfdata_size = swap_endian32(toc_anims[i].kfdata_size);
        fwrite(&toc_anims[i].animdata_offset, member_size(BinFile_TOC_Anims, animdata_offset), 1, fp);
        fwrite(&toc_anims[i].animdata_size, member_size(BinFile_TOC_Anims, animdata_size), 1, fp);
        fwrite(&toc_anims[i].kfdata_offset, member_size(BinFile_TOC_Anims, kfdata_offset), 1, fp);
        fwrite(&toc_anims[i].kfdata_size, member_size(BinFile_TOC_Anims, kfdata_size), 1, fp);
    }

    // Write the anim data + keyframes
    for (i=0; i<list_animations.size; i++)
    {
        int j;
        for (j=0; j<animdatas[i].kfcount; j++)
            animdatas[i].kfindices[j] = swap_endian16(animdatas[i].kfindices[j]);
        animdatas[i].kfcount = swap_endian32(animdatas[i].kfcount);
        fwrite(&animdatas[i].kfcount, member_size(BinFile_AnimData, kfcount), 1, fp);
        fwrite(animdatas[i].kfindices, sizeof(uint16_t)*swap_endian32(animdatas[i].kfcount), 1, fp);
        fwrite(animdatas[i].name, strlen(animdatas[i].name)+1, 1, fp);
        writepadding(fp, swap_endian32(toc_anims[i].animdata_size));
        for (j=0; j<kftotal[i]; j++)
        {
            kfdatas[i][j].pos[0] = swap_endianfloat(kfdatas[i][j].pos[0]);
            kfdatas[i][j].pos[1] = swap_endianfloat(kfdatas[i][j].pos[1]);
            kfdatas[i][j].pos[2] = swap_endianfloat(kfdatas[i][j].pos[2]);
            kfdatas[i][j].rot[0] = swap_endianfloat(kfdatas[i][j].rot[0]);
            kfdatas[i][j].rot[1] = swap_endianfloat(kfdatas[i][j].rot[1]);
            kfdatas[i][j].rot[2] = swap_endianfloat(kfdatas[i][j].rot[2]);
            kfdatas[i][j].rot[3] = swap_endianfloat(kfdatas[i][j].rot[3]);
            kfdatas[i][j].scale[0] = swap_endianfloat(kfdatas[i][j].scale[0]);
            kfdatas[i][j].scale[1] = swap_endianfloat(kfdatas[i][j].scale[1]);
            kfdatas[i][j].scale[2] = swap_endianfloat(kfdatas[i][j].scale[2]);
            fwrite(&kfdatas[i][j].pos[0], member_size(BinFile_KeyFrame, pos), 1, fp);
            fwrite(&kfdatas[i][j].rot[0], member_size(BinFile_KeyFrame, rot), 1, fp);
            fwrite(&kfdatas[i][j].scale[0], member_size(BinFile_KeyFrame, scale), 1, fp);
        }
    }
    fclose(fp);


    // -------------- Helper Header File --------------
    
    // Open the file
    sprintf(strbuff, "%s.h", global_outputname);
    fp = fopen(strbuff, "w+");
    if (fp == NULL)
        terminate("Error: Unable to open file for writing\n");

    // Print the header
    write_header(fp, makestructs);

    // Print texture count and texture list
    texturecount = 0;
    for (curnode = list_materials.head; curnode != NULL; curnode = curnode->next)
    {
        n64Material* tex = (n64Material*)curnode->data;
        if (isvalidmat(tex) && tex->type == TYPE_TEXTURE)
        {
            int len = strlen(tex->name);
            texturecount++;
            if (len > longesttexname)
                longesttexname = len;
        }
    }
    if (texturecount > 0)
    {
        fprintf(fp, "// Texture data\n#define TEXTURECOUNT_%s %d\n\n", global_modelname, texturecount);
        for (curnode = list_materials.head; curnode != NULL; curnode = curnode->next)
        {
            int nspaces;
            n64Material* tex = (n64Material*)curnode->data;
            int tindex = get_validtexindex(&list_materials, tex->name);
            if (tindex != -1)
            {
                fprintf(fp, "#define TEXTURE_%s ", tex->name);
                nspaces = strlen(tex->name);
                for (i=nspaces; i<longesttexname; i++) fputc(' ', fp);
                fprintf(fp, "%d\n", tindex);
            }
        }
    }

    // Print the extern definitions
    if (!global_opengl)
    {
        fprintf(fp, "\n// Extern definitions\n");
        fprintf(fp, "extern u8 _%sSegmentRomStart[];\n", global_modelname);
        fprintf(fp, "extern u8 _%sSegmentRomEnd[];", global_modelname);
    }

    // Done
    fclose(fp);

    // Finished writing the output
    if (!global_quiet) printf("Wrote output to '%s.bin' and '%s.h'\n", global_outputname, global_outputname);
}